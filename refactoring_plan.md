# План рефакторинга проекта Telegram Chat Exporter

Этот документ описывает стратегию и шаги по комплексному рефакторингу проекта с целью повышения его качества, надежности и расширяемости.

## 1. Анализ и принципы (ТРИЗ и ТОС)

### Теория ограничений (ТОС)

-   **Основное ограничение:** **Отсутствие автоматических тестов.** Это делает любые изменения в коде рискованными и замедляет разработку. Устранение этого ограничения (пункт 7) является ключевой задачей.
-   **Второстепенное ограничение:** **Монолитная функция `main()` и смешение логики.** Конфигурация, оркестрация и UI смешаны в одном месте, что усложняет поддержку.

### Теория решения изобретательских задач (ТРИЗ)

-   **Противоречие:** Код должен быть одновременно **гибким** (настраиваемым) и **простым** в использовании.
-   **Принципы решения:**
    1.  **Принцип сегментации (дробления):** Разделить монолитную `main()` на логические компоненты: конфигурация, ядро приложения, UI.
    2.  **Принцип вынесения:** Вынести конфигурацию (пути, параметры) из кода в отдельный файл или класс.
    3.  **Принцип универсальности:** Использовать стандартные инструменты (`logging`, `pytest`, `ruff`, `pyproject.toml`) для унификации разработки и поддержки.

---

## 2. Новая архитектура

Проект будет перестроен по слоеной архитектуре:

1.  **Слой представления (UI Layer):** `src/cli.py`
    -   Отвечает за все взаимодействие с пользователем (меню, ввод данных).
    -   Использует `rich`.
    -   Не содержит бизнес-логики, только вызывает методы из слоя приложения.

2.  **Слой приложения (Application Layer):** `src/app.py`
    -   Класс `ExporterApp`, который является ядром приложения.
    -   Оркестрирует работу: получает конфигурацию от UI, вызывает `TelegramFetcher` и `DocxExporter`.

3.  **Слой сервисов (Services Layer):** `src/tg_client.py`, `src/docx_client.py`
    -   Существующие клиенты, которые будут доработаны для лучшей интеграции и тестируемости.

4.  **Слой конфигурации (Configuration Layer):** `src/config.py`
    -   Датаклассы для хранения всех настроек (пути, параметры API, опции экспорта).

5.  **Точка входа:** `main.py`
    -   Минимальный файл, который импортирует и запускает `cli`.

## 3. E2E Пайплайн

1.  **Запуск:** Пользователь запускает `python main.py`.
2.  **UI:** `cli.py` отображает меню и собирает все необходимые данные от пользователя.
3.  **Конфигурация:** `cli.py` создает объект конфигурации и передает его в `ExporterApp`.
4.  **Выполнение:** `ExporterApp` запускает процесс экспорта:
    -   Инициализирует `TelegramFetcher`.
    -   Получает `ContentBlock`.
    -   Инициализирует `DocxExporter`.
    -   Передает блоки в экспортер.
    -   Сохраняет файл.
5.  **Обратная связь:** `cli.py` получает результат (успех/ошибка) и сообщает пользователю.

---

## 4. Техническое задание (ТЗ)

1.  **Переход на `uv` и `pyproject.toml`:**
    -   Удалить `venv` и `requirements.txt`.
    -   Создать `pyproject.toml` с описанием проекта и зависимостями.
    -   Настроить `ruff` для линтинга и форматирования.

2.  **Внедрение `logging`:**
    -   Заменить все `print()` на вызовы `logging`.
    -   Настроить базовый конфигуратор логов (уровень, формат, вывод в консоль).

3.  **Рефакторинг кода:**
    -   Реализовать новую архитектуру, разделив код на модули (`cli.py`, `app.py`, `config.py`).
    -   Упростить `main.py` до точки входа.
    -   Объединить утилиты в `src/utils.py`.

4.  **Документация (Docstrings):**
    -   Все публичные модули, классы и функции должны иметь docstrings в стиле Google.

5.  **Тестирование:**
    -   Использовать `pytest`.
    -   Создать директорию `tests/`.
    -   Написать юнит-тесты для каждого модуля в `src/`, используя моки для внешних API.
    -   Написать интеграционные тесты для проверки взаимодействия компонентов.
    -   Целевое покрытие кода — 95-100%.

## 5. План реализации

1.  **Шаг 1: Подготовка окружения.**
    -   Создать `pyproject.toml`.
    -   Установить `uv` и зависимости.
    -   Настроить `ruff` и провести первичное форматирование.
2.  **Шаг 2: Внедрение логирования.**
    -   Заменить `print` на `logging` во всем проекте.
3.  **Шаг 3: Рефакторинг архитектуры.**
    -   Создать новые файлы (`app.py`, `cli.py`, `config.py`).
    -   Перенести логику из `main.py` в соответствующие модули.
4.  **Шаг 4: Написание тестов.**
    -   Написать юнит-тесты для `utils`, `config`, `docx_client`, `tg_client`.
    -   Написать интеграционные тесты для `app.py`.
5.  **Шаг 5: Документирование.**
    -   Написать docstrings для всего нового и измененного кода.
6.  **Шаг 6: Финальная проверка.**
    -   Запустить все тесты и линтеры.
    -   Обновить `README.md`.
